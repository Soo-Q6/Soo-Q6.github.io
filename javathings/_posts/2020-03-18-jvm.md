---
title: Java虚拟机
# image: /assets/img/blog/...
description: >
  Java虚拟机学习笔记
# cofigure what you want to add in the end of the post, [about, newsletter, related, random, license]
addons: [license]
# the tag of post.
---

Java和C++之间有一堵由内存动态分配和垃圾回收技术所构成的高墙...<br>

# Java运行时数据区域
Java虚拟机在执行Java程序时会把它所管理的内存划分为不同的数据区域。有的区域随着虚拟机进程的启动而存在(方法区，堆)，有的则依赖于用户线程的生命周期而建立和销毁(虚拟机栈，本地方法栈和程序计数器).

## 程序计数器
线程私有，用于记录线程的执行位置，Java虚拟机规范中唯一没有规定任何**OutOfMemoryError**的区域。

## Java虚拟机栈
线程私有，用于描述Java方法执行的内存模型(方法的执行，对应着一个栈帧的入栈和出栈过程，**栈帧**保存着方法的局部变量表，操作数栈，动态链接，方法出口等信息)。
1. 局部变量表

存放各种基本数据类型，对象引用和返回地址类型(指向一条字节码指令的地址)。

2. 操作数栈

3. 动态链接

4. 方法出口
估计是return的地址

## 本地方法栈
和Java虚拟机栈一样，线程私有，用于描述native方法的执行模型

## Java堆
线程共有，是Java虚拟机管理的内存中最大的一块，用于存放对象实例("所有的"对象实例和数组都存放在这里)。堆还细分为新生代(包括Eden空间，from survivor空间和to survivor空间)和老年代。

## 方法区
线程共有，用于存储已被虚拟机加载的类信息，常量，静态变量等数据。这一部分的垃圾回收主要针对常量池的回收和对类型的卸载。(JDK 7之后将永久代的字符串常量池移出,然后放哪了?)

## 直接内存
直接内存不是运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。<br>
NIO，引入一种基于通道和缓冲区的IO方式，通过native函数直接分配堆外内存，然后通过Java堆中的DirectiveByteBuffer对这块内存的引用进行操作。

# Java对象的生命周期
包括Java堆中对象分配，布局和访问的全过程

## 对象的创建
new时，首先检查能否在常量池中定位到类的符号引用，并检查类是否被加载，解析和初始化。<br>

然后分配内存。主要包括指针碰撞和空闲列表，使用CAS+重试结果并发场景下内存分配的安全问题，或者使用TLAB分配内存<br>

接下来初始化内存空间<br>

设置对象头信息

> Java中对象的内存布局，包括对象头，实例数据和对齐填充


## 对象的访问定位
Java程序需要通过栈上的reference来操作堆上的具体对象。目前主流的访问方式由使用**句柄**和**直接使用指针**两种。

# Java的垃圾回收

考虑哪些内存需要回收，什么时候回收，如何回收？

## 对象已死？
1. 引用计数法<br>
给每一个对象添加一个引用计数器，每当对象被引用，计数器加一；当引用失效，计数器减一。计数器为零时对象不再使用。
**引用计数器缺点，不能解决对象之间的相互循环引用问题。**

2. 可达性分析

基本思路，使用**GC Roots**维护对象的引用链，当一个对象到GC Roots没有引用链相连时(不可达)，对象不可用。<br>

3. 不可达即死亡？<br>
实际上判断对象已死需要两次标记的过程，一次为不可达时，一次为F-Queue中。对象唯一的逃脱机会是在`finalize`中重新于引用链上对象建立连接

> Java中可作为GC Roots对象的有:
>
> 虚拟机栈(栈帧中的本地变量表)中引用的对象<br>
> 方法区中类静态属性引用的对象<br>
> 方法区中常量引用的对象<br>
> 本地方法中JNI引用的对象

## 垃圾回收算法
1. 标记-清除算法<br>
首先标记出所需要回收的对象，在标记完成后统一回收所有被标记的对象。**存在问题：标记和清除两个过程效率不高，会产生大量的内存碎片**
2. 复制算法<br>
将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完了，就将存活的对象复制到另外一块内存中，然后再把已使用的内存空间一次清理掉。**实现简单，不会产生内存碎片，但代价是内存空间缩小一半。**
3. 标记-整理算法<br>
先标记，后将存活对象全部往一端移动。
4. 分代收集算法

## 垃圾收集器
没有最好的收集器，只能根据应用选择最适合的收集器
![]({{site.data.strings.javaThing_url}}gcs.png)

### Serial收集器
这是一个单线程的收集器，在进行垃圾收集时，会暂停其他所有的工作线程，直到收集结束(**Stop the World**)
![]({{site.data.strings.javaThings_url}}serial.png)

### ParNew收集器
ParNew收集器是Serial收集器的多线程版本，除了使用多线程，其他的功能和Serial收集器基本一样。但在单CPU的情况下，ParNew不一定比Serial优秀。当然，随着CPU数量的增加，效率还是会提升的。ParNew默认开启的收集线程数和CPU数相同
![]({{site.data.strings.javaThings_url}}par.png)

> 这里说一下并发和并行：
>
> 并行(Parallel)，指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>
> 并发(Concurrent)，指用户线程于垃圾收集线程同时执行，但不一定是并行的，可能会交替执行，用户线程仍在继续运行。

### Parallel Scavenge收集器
一个新生代收集器，使用复制算法，又是并行多线程的。(看上去和ParNew一样？)<br>
PS关注的是达到一个可控制的吞吐量(User_time/(User_time+GC_time))，有两个可调整的参数：`-XX:MaxGCPauseMillis`和`-XX:GCTimeRatio`。不过偷懒可以使用它的**GC自适应调节策略**。

### Serial Old收集器
Serial的老年代版本，是一个单线程收集器，使用标记整理算法。主要有两个用途：
1. 在JDK 1.5之前和Parallel Scavenge搭配使用
2. 作为CMS收集器的后备预案，在并发收集发生**Concurrent Mode Failure**时使用

![]({{site.data.strings.javaThings_url}}serial.png)

### Parallel Old收集器
是Parallel Scavenge的老年代版本，多线程以及使用标记整理算法。在Parallel Old之前，Parallel Scavenge只能和Serial Old搭配只用...

![]({{site.data.strings.javaThings_url}}parold.png)

### CMS收集器
CMS(Concurrernt Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记清除算法，并发执行。<br>
不过它的运作过程相对复杂：
1. 初始标记<br>
仅仅标记GC Roots能直接关联到的对象，速度很快，STW
2. 并发标记<br>
进行RG Roots Tracing的过程，与用户线程并发执行
3. 重新标记<br>
为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记稍慢
4. 并发清除<br>
清除标记对象，与用户线程并发执行

虽说是并发而且低停顿，但它还不是完美的：
1. 并发阶段虽不会STW，但是CPU的吞吐量下降，导致应用程序线程变慢。默认回收线程数为(CPU数量+3)/4
2. 无法处理浮动垃圾(出现在标记过程之后的垃圾)，科恩那个会出现**Concurrent Mode Failure**而导致另一次Full GC的产生(临时启用Serial Old)；*同时也需要预留一部分内存空间给用户线程，预留的越少，出现CMF的几率越大*。
3. 基于标记清除算法，会产生大量的内存空间碎片，这里就不得不触发一次Full GC进行内存整理。


### G1收集器
