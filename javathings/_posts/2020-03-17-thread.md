---
title: Java中的线程
# image: /assets/img/blog/...
description: >
  记录一下Java中线程的用法
# cofigure what you want to add in the end of the post, [about, newsletter, related, random, license]
addons: [license]
# the tag of post.
---

多线程是非常复杂的机制。一个线程是进程中的一个执行流程，一个进程中可以同时包含多个线程，每个线程可以得到一小段程序的执行时间(CPU时间片)，这样进程就可以具有多个并发执行的线程。<br>

## Java中线程的实现方式
主要包含无返回类型的Tread和Runable，以及有返回类型的基于Executor框架的方法。
### 继承Thread类
```java
public class ThreadDemo extends Thread{
    public  void run(){
        try {
            sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        for (int i =0;i<5;i++) {
            ThreadDemo t = new ThreadDemo();
            t.setName("test"+i);
            t.start();
        }
        System.out.println(Thread.currentThread().toString());
    }

}
```
> Thread其实是实现了Runable接口的。

### 实现Runable接口
这里通过[匿名内部类]()实现了Runable接口。当然也可以将一个已实现RUnable接口的类作为形参传递到Thread的构造函数中。
```java
public class ThreadDemo{
    public static void main(String[] args) {
        for (int i =0;i<5;i++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().toString());
                }
            });
            t.setName("test"+i);
            t.start();
        }
        System.out.println(Thread.currentThread().toString());
    }

}
```

### 基于Executor框架的

## Java线程的生命周期
Java线程有`NEW`，`RUNNALBE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`以及`TERMINATED`六种状态(可以从Thread的源码中可以找到)
![]({{site.data.strings.javaThing_url}}thread.png)<br>

1. `NEW`: 创建但还没有`start()`。
2. `RUNNABLE`: 在JVM中执行但有可能在等待CPU时间片的分配(多线程并发)。
3. `BLOCKED`: 被同步锁阻塞，由synchronized的代码块或者synchronized的方法阻塞。
4. `WAITING`: 等待，需要被唤醒(`notify()`,`notifyAll()`)才能变回`RUNNABLE`, 由`Object.wait()`, `Thread.join()`或者` LockSupport.park()`引起的。
5. `TIMED_WAITING`: 等待一段时间，由`Thread.sleep()`,`Object.wait(long)`,`Thread.join(long)`,`LockSupport.parkNanos()`或者`LockSupport.parkUntil()`引起的。
6. `TERMINATED`: 线程终止。


## 线程的同步机制
1. 同步块
```java
// o为任意对象，通过对象的标志位来判断是否有其他线程正在执行
synchronized(Object o){
    // anything...
}
```
2. 同步方法
```java
synchronized void f(){
    // anything...
} 
```

## 线程间的通信