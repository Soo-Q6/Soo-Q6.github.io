---
title: Java中的Map
# image: /assets/img/blog/...
description: >
  记录一下Java中Map接口及其实现HashMap
# cofigure what you want to add in the end of the post, [about, newsletter, related, random, license]
addons: [license]
# the tag of post.
---

主要涉及HashMap(jdk1.2)的一些原理介绍。<br>

## HashMap是什么
HashMap，实现了Map，是一个哈希数组结构(Entry)，数组元素是一个key-value对，并且使用单链表解决冲突。<br>
HashMap数据存储过程：通过key计算hash值，然后通过hash值找到key-value对的存储位置，然后表尾插入value。
HashMap有以下特点：<br>
1. 非线程安全
2. 哈希数组可扩容
3. key唯一，且key，value均可为null
4. 实现Cloneable, Serializable接口


## HashTable
HashTable(jdk1.0)也是基于哈希数组，元素是key-value对，并且使用单链表解决冲突，哈希数组可扩容，线程安全，实现Cloneable, Serializable接口。

## ConcurrentHashMap
线程安全，CAS+同步锁，数组+链表+红黑树，key和value不为null

### 源码分析
这里主要看看是怎么实现线程安全的

## HashMap和HashTable的区别
两者主要有以下的不同
### 继承父类不同
HashMap：
```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
```
HashTable:
```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {
```
其中，Dictionary已弃用

### 线程安全
1. HashMap是线程不安全的，在多个线程同时访问一个哈希映射，**且至少一个线程修改了该映射**， 需要在外部实现同步

2. HashTable是线程安全的，其方法大都是Synchronize的，它实现线程安全效率比较低，会将整个HashTable锁住(ConcurrentHashMap则使用的分段锁，效率要好很多)。

### contains()
HashMap是没有contains()的，而HashTable则保留了contains()，效果类似于ContrainValue()。

### null值
HashMap的key和value都可以为null，而HashTable的key和value都不能为null

### 计算hash值的方法不同
HashMap：
```java
    /**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don't benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
HashTable:
```java
int hash = key.hashCode();
```

### 计算索引
HashMap固定哈希数组的长度为2的次幂，因此可以通过位运算计算index，效率要高很多:
```java
//n为哈希数组长度
int index = (n-1) & hash;
```
HashTable：
```java
// &运算，变换正负号
int index = (hash & 0x7FFFFFFF) % tab.length;
``` 

### 扩容
HashMap扩为原来大小的两倍，而HashTable扩容为原来的2倍+1

### 处理冲突
JDK1.8之后，HashMap解决冲突思路：<br>
1. 冲突数量小于8，按照正常的链表解决法
2. 冲突数量大于等于8，将链表转换为红黑树(不保证迭代顺序)

HashTable：使用链表解决法